#!/usr/bin/env python
"""
su2_py_wrapper.py

Utilities to turn an in-memory SU2 JSON description into
 • a SU2‐style *.cfg text file,
 • a copy of the JSON for reference,
 • and a self-contained Python driver (wrapper) that can be executed
   directly with MPI or the CPython interpreter.

The generated wrapper follows the same layout as `run_su2.py`:
    ├─ imports (pysu2, mpi4py, numpy, …)
    ├─ user-defined “Variables” section
    ├─ “Derived parameters” helper functions (optional stubs)
    ├─ a single triple-quoted `config_settings` string
    └─ a `main()` that constructs and runs a `pysu2.CSinglezoneDriver`.
"""

from __future__ import annotations

import json
import os
import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Sequence

# ----------------------------------------------------------------------
# optional project-internal imports (will be present when run
# inside your larger code-base, otherwise they are silently ignored)
# ----------------------------------------------------------------------
try:
    from core.su2_json import state  # type: ignore
    from core.logger import log      # type: ignore
except ModuleNotFoundError:          # for standalone usage / unit tests
    class _DummyLogger:              # minimal replacement
        @staticmethod
        def log(lvl: str, msg: str) -> None:
            print(f"[{lvl.upper():5}] {msg}")
    log = _DummyLogger().log          # type: ignore
    state = type("DummyState", (),   # type: ignore
                 {"case_name": "dummy_case",
                  "counter": 0,
                  "jsonData": {},
                  "config_desc": "# SU2 configuration generated by su2_py_wrapper"})()

BASE_DIR = Path(__file__).resolve().parent.parent      # project root


# ----------------------------------------------------------------------
# helpers
# ----------------------------------------------------------------------
def _flatten(lst: Sequence[Any]) -> List[Any]:
    """Recursively flatten any nested sequence (list/tuple)."""
    flat: List[Any] = []
    for item in lst:
        if isinstance(item, (list, tuple)):
            flat.extend(_flatten(item))
        else:
            flat.append(item)
    return flat


_VAR_PATTERN = re.compile(r"\b([A-Za-z_]\w*)\b")


def _replace_variables(text: str, variables: Dict[str, Any]) -> str:
    """Replace bare variable names in *text* with their current values."""
    def repl(match: re.Match[str]) -> str:
        key = match.group(1)
        return str(variables.get(key, key))
    return _VAR_PATTERN.sub(repl, text)


def _to_cfg_value(value: Any,
                  variables: Dict[str, Any]) -> str | None:
    """
    Convert a Python value coming from the JSON description into the exact
    literal that SU2 expects inside the .cfg file.

    • `None`    ->  ignored  (returns *None*)
    • `bool`    ->  YES / NO
    • sequence  ->  "(a, b, c)"
    • other     ->  string with variable substitution
    """
    if value is None or (isinstance(value, str) and value.lower() == "none"):
        return None

    if isinstance(value, bool):
        return "YES" if value else "NO"

    if isinstance(value, (list, tuple)):
        flat = [_replace_variables(str(v), variables) for v in _flatten(value)]
        return "(" + ", ".join(flat) + ")"

    # plain scalar / str
    return _replace_variables(str(value), variables)


# ----------------------------------------------------------------------
# main generator
# ----------------------------------------------------------------------
def generate_python_wrapper(
        json_data: Dict[str, Any],
        filename_py_export: str | Path,
        *,
        variables: Dict[str, Any] | None = None,
        derived_parameters: Dict[str, str] | None = None,
        output_dir: str | Path | None = None,
        config_filename: str = "config.cfg"
) -> Path:
    """
    Build the wrapper file and return its Path.

    *variables*          dict of named variables to inject at the top
    *derived_parameters* mapping name → short documentation string
    *output_dir*         override default "user/<case_name>" directory
    *config_filename*    name of the config file to reference
    """
    variables = variables or {}
    derived_parameters = derived_parameters or {}

    log("info", "Generating Python wrapper script")
    filename_py_export = Path(filename_py_export).with_suffix(".py")

    # decide where to put the result
    if output_dir is None:
        output_dir = BASE_DIR / "user" / state.case_name
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    target_file = output_dir / filename_py_export
    log("info", f"Output file: {target_file}")

    # ---------- write file -------------------------------------------------
    with target_file.open("w", encoding="utf-8") as f:
        # shebang & imports
        f.write("#!/usr/bin/env python\n\n")
        f.write("import pysu2\n")
        f.write("import numpy as np\n")
        f.write("from mpi4py import MPI\n")
        f.write("import math, os, sys\n\n")

        # user variables
        if variables:
            f.write("# ----------------------\n# Variables injected by user\n")
            for k, v in variables.items():
                f.write(f"{k} = {v!r}\n")
            f.write("\n")

        # derived parameters (stubs)
        if derived_parameters:
            f.write("# ----------------------\n# Derived-parameter helpers\n")
            for name, doc in derived_parameters.items():
                f.write(f"def calculate_{name}(driver):\n")
                f.write(f"    \"\"\"{doc}\"\"\"\n")
                f.write("    # TODO: implement the real formula\n")
                f.write("    return 0.0\n\n")        # configuration file reference
        f.write("# ----------------------\n# SU2 configuration file path\n")
        f.write(f"config_file = '{config_filename}'\n\n")        # driver
        f.write(
            "def main():\n"
            "    comm  = MPI.COMM_WORLD\n"
            "    rank  = comm.Get_rank()\n"
            "    \n"
            "    # Check if config file exists\n"
            "    if not os.path.exists(config_file):\n"
            "        if rank == 0:\n"
            "            print(f'Error: Configuration file {config_file} not found')\n"
            "        return 1\n"
            "    \n"
            "    try:\n"
            "        driver = pysu2.CSinglezoneDriver(config_file, 1, comm)\n"
            "        driver.Preprocess(0)\n"
            "        driver.Run()\n"
            "        driver.Postprocess()\n"
            "        if rank == 0:\n"
            "            print('SU2 simulation completed successfully')\n"
            "    except Exception as exc:\n"
            "        if rank == 0:\n"
            "            print(f'Error running SU2: {exc}')\n"
            "        return 1\n"
            "    return 0\n\n\n"
            "if __name__ == '__main__':\n"
            "    raise SystemExit(main())\n"
        )

    # make executable on Unix-likes
    try:
        target_file.chmod(target_file.stat().st_mode | 0o111)
    except PermissionError:
        pass

    log("info", f"Python wrapper generated at: {target_file}")
    return target_file

# ----------------------------------------------------------------------
# higher-level convenience wrapper used by the rest of the code-base
# ----------------------------------------------------------------------
def save_json_cfg_py_file(
        filename_json_export: str | Path,
        filename_cfg_export : str | Path,
        filename_py_export : str | Path,
        *,
        variables: Dict[str, Any] | None = None,
        derived_parameters: Dict[str, str] | None = None
) -> None:
    """
    Dump JSON + SU2 .cfg + wrapper.py files side-by-side into
    `user/<state.case_name>/`.
    """
    if not getattr(state, "case_name", ""):
        log("warn", "Case name not defined – nothing exported")
        return

    variables = variables or {}
    derived_parameters = derived_parameters or {}

    export_dir = BASE_DIR / "user" / state.case_name
    export_dir.mkdir(parents=True, exist_ok=True)

    # -------- JSON --------------------------------------------------------
    json_path = export_dir / Path(filename_json_export).with_suffix(".json")
    with json_path.open("w", encoding="utf-8") as fp:
        json.dump(state.jsonData, fp, indent=4, sort_keys=True, ensure_ascii=False)
    log("info", f"Wrote JSON    → {json_path}")

    # -------- CFG ---------------------------------------------------------
    cfg_path = export_dir / Path(filename_cfg_export).with_suffix(".cfg")
    with cfg_path.open("w", encoding="utf-8") as fp:
        fp.write(f"{state.config_desc}\n")
        for k, v in state.jsonData.items():
            cfg_val = _to_cfg_value(v, variables)
            if cfg_val is None:
                continue
            fp.write(f"{k}= {cfg_val}\n")
    log("info", f"Wrote .cfg    → {cfg_path}")    # create *.py wrapper next to them
    generate_python_wrapper(
        state.jsonData,
        filename_py_export=filename_py_export,
        variables=variables,
        derived_parameters=derived_parameters,
        output_dir=export_dir,
        config_filename=Path(filename_cfg_export).with_suffix(".cfg").name,
    )

    # simple counter to help your own bookkeeping
    state.counter = getattr(state, "counter", 0) + 1
    log("info", f"Export counter: {state.counter}")
