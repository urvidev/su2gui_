#!/usr/bin/env python

from __future__ import annotations

import json
import os
import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Sequence


try:
    from core.su2_json import state  
    from core.logger import log      
except ModuleNotFoundError:         
    class _DummyLogger:              
        @staticmethod
        def log(lvl: str, msg: str) -> None:
            print(f"[{lvl.upper():5}] {msg}")
    log = _DummyLogger().log          
    state = type("DummyState", (),   
                 {"case_name": "dummy_case",
                  "counter": 0,
                  "jsonData": {},
                  "config_desc": "# SU2 configuration generated by su2_py_wrapper"})()

BASE_DIR = Path(__file__).resolve().parent.parent      # project root


# ----------------------------------------------------------------------
# helpers
# ----------------------------------------------------------------------
def _flatten(lst: Sequence[Any]) -> List[Any]:
    # Recursively flatten any nested sequence (list/tuple).
    flat: List[Any] = []
    for item in lst:
        if isinstance(item, (list, tuple)):
            flat.extend(_flatten(item))
        else:
            flat.append(item)
    return flat


_VAR_PATTERN = re.compile(r"\b([A-Za-z_]\w*)\b")


def _replace_variables(text: str, variables: Dict[str, Any]) -> str:
    """Replace bare variable names in *text* with their current values."""
    def repl(match: re.Match[str]) -> str:
        key = match.group(1)
        return str(variables.get(key, key))
    return _VAR_PATTERN.sub(repl, text)


def _to_cfg_value(value: Any,
                  variables: Dict[str, Any]) -> str | None:
    
    if value is None or (isinstance(value, str) and value.lower() == "none"):
        return None

    if isinstance(value, bool):
        return "YES" if value else "NO"

    if isinstance(value, (list, tuple)):
        flat = [_replace_variables(str(v), variables) for v in _flatten(value)]
        return "(" + ", ".join(flat) + ")"

    # plain scalar / str
    return _replace_variables(str(value), variables)


# ----------------------------------------------------------------------
# main generator
# ----------------------------------------------------------------------
def generate_python_wrapper(
        json_data: Dict[str, Any],
        filename_py_export: str | Path,
        *,
        variables: Dict[str, Any] | None = None,
        derived_parameters: Dict[str, str] | None = None,
        dynamic_wall_temp_markers: Dict[str, str] | None = None,
        output_dir: str | Path | None = None,
        config_filename: str = "config.cfg"
) -> Path:
    
    variables = variables or {}
    derived_parameters = derived_parameters or {}
    dynamic_wall_temp_markers = dynamic_wall_temp_markers or {}

    log("info", "Generating Python wrapper script")
    filename_py_export = Path(filename_py_export).with_suffix(".py")

    # decide where to put the result
    if output_dir is None:
        output_dir = BASE_DIR / "user" / state.case_name
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    target_file = output_dir / filename_py_export
    log("info", f"Output file: {target_file}")

    # ---------- write file -------------------------------------------------
    with target_file.open("w", encoding="utf-8") as f:
        # shebang & imports
        f.write("#!/usr/bin/env python\n\n")
        f.write("import pysu2\n")
        f.write("import numpy as np\n")
        f.write("from mpi4py import MPI\n")
        f.write("import math, os, sys\n\n")

        # user variables
        if variables:
            f.write("# ----------------------\n# Variables injected by user\n")
            for k, v in variables.items():
                f.write(f"{k} = {v!r}\n")
            f.write("\n")

        # derived parameters (stubs)
        if derived_parameters:
            f.write("# ----------------------\n# Derived-parameter helpers\n")
            for name, doc in derived_parameters.items():
                f.write(f"def calculate_{name}(driver):\n")
                f.write(f"    \"\"\"{doc}\"\"\"\n")
                f.write("    # TODO: implement the real formula\n")
                f.write("    return 0.0\n\n")        # configuration file reference
        f.write("# ----------------------\n# SU2 configuration file path\n")
        f.write(f"config_file = '{config_filename}'\n\n")        # driver
        f.write(
            "def main():\n"
            "    comm  = MPI.COMM_WORLD\n"
            "    rank  = comm.Get_rank()\n"
            "    \n"
            "    # Check if config file exists\n"
            "    if not os.path.exists(config_file):\n"
            "        if rank == 0:\n"
            "            print(f'Error: Configuration file {config_file} not found')\n"
            "        return 1\n"
            "    \n"
            "    try:\n"
            "        driver = pysu2.CSinglezoneDriver(config_file, 1, comm)\n"
            "        driver.Preprocess(0)\n"
            "        driver.Run()\n"
            "        driver.Postprocess()\n"
            "        if rank == 0:\n"
            "            print('SU2 simulation completed successfully')\n"
            "    except Exception as exc:\n"
            "        if rank == 0:\n"
            "            print(f'Error running SU2: {exc}')\n"
            "        return 1\n"
            "    return 0\n\n\n"
            "if __name__ == '__main__':\n"
            "    raise SystemExit(main())\n"
        )

    # make executable 
    try:
        target_file.chmod(target_file.stat().st_mode | 0o111)
    except PermissionError:
        pass

    log("info", f"Python wrapper generated at: {target_file}")
    return target_file

def generate_dynamic_temperature_wrapper(
        boundary_marker: str,
        base_temperature: float = 300.0,
        filename_py_export: str | Path = "run_su2_dynamic.py",
        *,
        amplitude: float = 257.0,
        frequency: float = 0.5,
        output_dir: str | Path | None = None,
        variables: Dict[str, Any] | None = None,
        temperature_formula: str | None = None
) -> Path:
    
    log("info", f"Generating dynamic temperature wrapper for marker: {boundary_marker}")
    
    # Initialize defaults
    variables = variables or {}
    if temperature_formula is None:
        temperature_formula = "BASE_TEMPERATURE + AMPLITUDE * math.sin(math.pi * FREQUENCY * time)"
    
    # Set default variables if not provided by user
    default_variables = {
        "BASE_TEMPERATURE": base_temperature,
        "AMPLITUDE": amplitude,
        "FREQUENCY": frequency
    }
    
    # Merge user variables with defaults (user variables take precedence)
    all_variables = {**default_variables, **variables}
    
    filename_py_export = Path(filename_py_export).with_suffix(".py")
    
    # decide where to put the result
    if output_dir is None:
        output_dir = BASE_DIR / "user" / state.case_name
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    target_file = output_dir / filename_py_export
    log("info", f"Output file: {target_file}")

    # ---------- write file -------------------------------------------------
    with target_file.open("w", encoding="utf-8") as f:
        # imports
        f.write("#!/usr/bin/env python\n\n")
        f.write("import pysu2\n")
        f.write("import numpy as np\n")
        f.write("from mpi4py import MPI\n")
        f.write("import math, os, sys\n\n")
        
        # dynamic temperature parameters
        f.write("# ----------------------\n# Dynamic Temperature Parameters\n")
        
        # Write all user-defined and default variables
        for var_name, var_value in all_variables.items():
            if isinstance(var_value, str):
                # Try to convert string to number 
                try:
                    if '.' in var_value or 'e' in var_value.lower():
                        # Try as float
                        numeric_value = float(var_value)
                        f.write(f"{var_name} = {numeric_value}  # {var_name}\n")
                    elif var_value.isdigit() or (var_value.startswith('-') and var_value[1:].isdigit()):
                        # Try as integer
                        numeric_value = int(var_value)
                        f.write(f"{var_name} = {numeric_value}  # {var_name}\n")
                    else:
                        # Keep as string
                        f.write(f"{var_name} = '{var_value}'  # {var_name}\n")
                except ValueError:
                    # Not a valid number, keep as string
                    f.write(f"{var_name} = '{var_value}'  # {var_name}\n")
            elif isinstance(var_value, (int, float)):
                f.write(f"{var_name} = {var_value}  # {var_name}\n")
            else:
                f.write(f"{var_name} = {var_value}  # {var_name}\n")
        
        f.write(f"WALL_MARKER = '{boundary_marker}'  # Wall boundary marker name\n")
        f.write(f"temperature_formula = '{temperature_formula}'  # Temperature formula\n\n")

        # configuration file reference
        f.write("# ----------------------\n# SU2 configuration file path\n")
        f.write("config_file = 'config.cfg'\n\n")
        
        # Define available mathematical functions and constants
        f.write("# ----------------------\n# Available math functions and constants\n")
        f.write("def get_math_functions():\n")
        f.write("    \"\"\"Return a dictionary of available math functions and constants.\"\"\"\n")
        f.write("    math_functions = {\n")
        f.write("        # Constants\n")
        f.write("        'pi': math.pi,\n")
        f.write("        'e': math.e,\n")
        f.write("        'inf': math.inf,\n")
        f.write("        'nan': math.nan,\n")
        f.write("        # Functions\n")
        f.write("        'sin': math.sin,\n")
        f.write("        'cos': math.cos,\n")
        f.write("        'tan': math.tan,\n")
        f.write("        'asin': math.asin,\n")
        f.write("        'acos': math.acos,\n")
        f.write("        'atan': math.atan,\n")
        f.write("        'atan2': math.atan2,\n")
        f.write("        'sinh': math.sinh,\n")
        f.write("        'cosh': math.cosh,\n")
        f.write("        'tanh': math.tanh,\n")
        f.write("        'exp': math.exp,\n")
        f.write("        'log': math.log,\n")
        f.write("        'log10': math.log10,\n")
        f.write("        'sqrt': math.sqrt,\n")
        f.write("        'pow': math.pow,\n")
        f.write("        'abs': abs,\n")
        f.write("        'ceil': math.ceil,\n")
        f.write("        'floor': math.floor,\n")
        f.write("        'round': round,\n")
        f.write("        'min': min,\n")
        f.write("        'max': max,\n")
        f.write("        'degrees': math.degrees,\n")
        f.write("        'radians': math.radians,\n")
        f.write("    }\n")
        f.write("    return math_functions\n\n")
        
        # Parse and validate formula
        f.write("def parse_formula(formula, time_value):\n")
        f.write("    \"\"\"Parse and evaluate the temperature formula safely.\"\"\"\n")
        f.write("    # Get all available math functions\n")
        f.write("    math_funcs = get_math_functions()\n")
        f.write("    \n")
        f.write("    # Create a local context with variables and time\n")
        f.write("    context = {**globals(), **math_funcs, 'time': time_value}\n")
        f.write("    \n")
        f.write("    # Remove any potentially dangerous functions\n")
        f.write("    for unsafe_func in ['eval', 'exec', '__import__', 'open', 'globals', 'locals']:\n")
        f.write("        if unsafe_func in context:\n")
        f.write("            del context[unsafe_func]\n")
        f.write("    \n")
        f.write("    try:\n")
        f.write("        # Using eval with restricted globals/locals is safer than string manipulation\n")
        f.write("        result = eval(formula, {}, context)\n")
        f.write("        return float(result)  # Ensure result is a float\n")
        f.write("    except Exception as e:\n")
        f.write("        print(f\"Error evaluating formula '{formula}': {e}\")\n")
        f.write("        # Return base temperature as fallback\n")
        f.write("        return BASE_TEMPERATURE\n\n")
        
        # dynamic temperature function using the parser
        f.write("def calculate_wall_temperature(time):\n")
        f.write("    \"\"\"Calculate dynamic wall temperature based on time using user-defined formula.\"\"\"\n")
        f.write("    return parse_formula(temperature_formula, time)\n\n")
        
        # main function with dynamic temperature control
        f.write(
            "def main():\n"
            "    comm = MPI.COMM_WORLD\n"
            "    rank = comm.Get_rank()\n"
            "    \n"
            "    # Check if config file exists\n"
            "    if not os.path.exists(config_file):\n"
            "        if rank == 0:\n"
            "            print(f'Error: Configuration file {config_file} not found')\n"
            "        return 1\n"
            "    \n"
            "    try:\n"
            "        # Initialize SU2 driver\n"
            "        driver = pysu2.CSinglezoneDriver(config_file, 1, comm)\n"
            "        \n"
            "        # Get number of time iterations from config or set default\n"
            "        nTimeIter = 100  # Adjust based on your simulation needs\n"
            "        \n"
            "        if rank == 0:\n"
            "            print(f'Starting dynamic temperature simulation with {nTimeIter} iterations')\n"
            "            print(f'Wall marker: {WALL_MARKER}')\n"
        )
        
        # Add dynamic printing of all variables
        for var_name in all_variables.keys():
            f.write(f"            print(f'{var_name}: {{{var_name}}}')\n")
        
        f.write(
            "            print(f'Temperature formula: {temperature_formula}')\n"
            "            # Test formula with sample time values\n"
            "            print('Formula test results:')\n"
            "            for test_time in [0, 1, 5, 10]:\n"
            "                temp = calculate_wall_temperature(test_time)\n"
            "                print(f'  t={test_time}: {temp:.2f}K')\n"
            "        \n"
            "        # Time iteration loop with dynamic temperature\n"
            "        for TimeIter in range(nTimeIter):\n"
            "            \n"
            "            # Preprocess for current time step\n"
            "            driver.Preprocess(TimeIter)\n"
            "            \n"
            "            # Calculate current wall temperature\n"
            "            current_time = float(TimeIter)  # You may need to get actual time from driver\n"
            "            wall_temp = calculate_wall_temperature(current_time)\n"
            "            \n"
            "            # Set dynamic wall temperature for all vertices on the wall marker\n"
            "            # Note: This requires SU2 to be compiled with Python custom BC support\n"
            "            try:\n"
            "                # Get marker ID for the wall boundary\n"
            "                marker_id = driver.GetMarkerIndex(WALL_MARKER)\n"
            "                if marker_id >= 0:\n"
            "                    # Get number of vertices on this marker\n"
            "                    n_vertices = driver.GetNumberVertices(marker_id)\n"
            "                    \n"
            "                    # Set temperature for each vertex\n"
            "                    for vertex_id in range(n_vertices):\n"
            "                        driver.SetMarkerCustomTemperature(marker_id, vertex_id, wall_temp)\n"
            "                    \n"
            "                    # Update boundary conditions\n"
            "                    driver.BoundaryConditionsUpdate()\n"
            "                    \n"
            "                    if rank == 0 and TimeIter % 10 == 0:\n"
            "                        print(f'  Time step {TimeIter}: Wall temperature = {wall_temp:.2f}K')\n"
            "                else:\n"
            "                    if rank == 0:\n"
            "                        print(f'Warning: Wall marker \"{WALL_MARKER}\" not found')\n"
            "            except Exception as e:\n"
            "                if rank == 0:\n"
            "                    print(f'Warning: Could not set custom temperature: {e}')\n"
            "                    print('Continuing with static temperature...')\n"
            "            \n"
            "            # Run iteration\n"
            "            driver.Run()\n"
            "            \n"
            "            # Postprocess\n"
            "            driver.Postprocess()\n"
            "            \n"
            "            # Update for next iteration\n"
            "            driver.Update()\n"
            "        \n"
            "        if rank == 0:\n"
            "            print('Dynamic temperature simulation completed successfully')\n"
            "            \n"
            "    except Exception as exc:\n"
            "        if rank == 0:\n"
            "            print(f'Error running SU2 with dynamic temperature: {exc}')\n"
            "        return 1\n"
            "    \n"
            "    return 0\n\n\n"
            "if __name__ == '__main__':\n"
            "    raise SystemExit(main())\n"
        )

    # make executable 
    try:
        target_file.chmod(target_file.stat().st_mode | 0o111)
    except PermissionError:
        pass

    log("info", f"Dynamic temperature wrapper generated at: {target_file}")
    
    # Also generate updated config file with Python custom markers
    _generate_dynamic_config_file(boundary_marker, base_temperature, output_dir)
    
    return target_file

def _generate_dynamic_config_file(boundary_marker: str, base_temperature: float, output_dir: Path):
    # Generate updated config file with Python custom boundary conditions.
    try:
        config_path = output_dir / "config.cfg"
        
        # Read existing config or create new one
        config_lines = []
        if config_path.exists():
            with config_path.open("r", encoding="utf-8") as f:
                config_lines = f.readlines()
        
        # Check if we need to add/update markers
        has_isothermal = False
        has_python_custom = False
        
        for i, line in enumerate(config_lines):
            if line.strip().startswith("MARKER_ISOTHERMAL"):
                # Update existing isothermal marker
                config_lines[i] = f"MARKER_ISOTHERMAL= ({boundary_marker}, {base_temperature})\n"
                has_isothermal = True
            elif line.strip().startswith("MARKER_PYTHON_CUSTOM"):
                # Update existing python custom marker
                config_lines[i] = f"MARKER_PYTHON_CUSTOM= ({boundary_marker})\n"
                has_python_custom = True
        
        # Add missing markers
        if not has_isothermal:
            config_lines.append(f"MARKER_ISOTHERMAL= ({boundary_marker}, {base_temperature})\n")
        if not has_python_custom:
            config_lines.append(f"MARKER_PYTHON_CUSTOM= ({boundary_marker})\n")
        
        # Write updated config
        with config_path.open("w", encoding="utf-8") as f:
            f.writelines(config_lines)
            
        log("info", f"Updated config file with dynamic temperature markers: {config_path}")
        
    except Exception as e:
        log("warn", f"Could not update config file: {e}")

# ----------------------------------------------------------------------
# higher-level convenience wrapper used by the rest of the code-base
# ----------------------------------------------------------------------
def save_json_cfg_py_file(
        filename_json_export: str | Path,
        filename_cfg_export : str | Path,
        filename_py_export : str | Path,
        *,
        variables: Dict[str, Any] | None = None,        derived_parameters: Dict[str, str] | None = None,
        dynamic_wall_temp_markers: Dict[str, str] | None = None
) -> str | None:
    
    if not getattr(state, "case_name", ""):
        log("warn", "Case name not defined – nothing exported")
        return None

    variables = variables or {}
    derived_parameters = derived_parameters or {}
    dynamic_wall_temp_markers = dynamic_wall_temp_markers or {}

    export_dir = BASE_DIR / "user" / state.case_name
    export_dir.mkdir(parents=True, exist_ok=True)

    # -------- JSON --------------------------------------------------------
    json_path = export_dir / Path(filename_json_export).with_suffix(".json")
    with json_path.open("w", encoding="utf-8") as fp:
        json.dump(state.jsonData, fp, indent=4, sort_keys=True, ensure_ascii=False)
    log("info", f"Wrote JSON    → {json_path}")

    # -------- CFG ---------------------------------------------------------
    cfg_path = export_dir / Path(filename_cfg_export).with_suffix(".cfg")
    with cfg_path.open("w", encoding="utf-8") as fp:
        fp.write(f"{state.config_desc}\n")
        for k, v in state.jsonData.items():
            cfg_val = _to_cfg_value(v, variables)
            if cfg_val is None:
                continue
            fp.write(f"{k}= {cfg_val}\n")
    log("info", f"Wrote .cfg    → {cfg_path}")
    
    # create *.py wrapper next to them and capture the path
    python_wrapper_path = None    # Choose which wrapper to generate based on dynamic_wall_temp_markers
    if dynamic_wall_temp_markers:
        # Use the dynamic temperature wrapper for airfoil marker
        for marker, temp_function in dynamic_wall_temp_markers.items():
            python_wrapper_path = generate_dynamic_temperature_wrapper(
                boundary_marker=marker,
                base_temperature=300.0,  # Default base temp
                filename_py_export=filename_py_export,
                output_dir=export_dir,
                variables=variables,
                temperature_formula=temp_function
            )
            break  # Only process the first marker for now
    else:        # Use standard wrapper
        python_wrapper_path = generate_python_wrapper(
            state.jsonData,
            filename_py_export=filename_py_export,
            variables=variables,
            derived_parameters=derived_parameters,
            dynamic_wall_temp_markers=dynamic_wall_temp_markers,
            output_dir=export_dir,
            config_filename=Path(filename_cfg_export).with_suffix(".cfg").name,
        )

    # simple counter to help your own bookkeeping
    state.counter = getattr(state, "counter", 0) + 1
    log("info", f"Export counter: {state.counter}")
    
    return str(python_wrapper_path) if python_wrapper_path else None
